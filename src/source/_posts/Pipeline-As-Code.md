---
title: Pipeline As Code
date: 2020-07-23 19:45:50
tags:
- DevOps
---
There are new buzz words that popup all the time in the DevOps world.  In the last few years one of those words that came up was Pipeline as Code.  Everything is coming down to turning it into code.  As developers this has always been a natural step for us because we have always begun with code that then gets compiled and turned into working software.  More than a decade ago there was a big push to try and retrain folks who worked on databases to think in terms of database as code and keep that code in Source Control the one single source of truth.  Since then you have probably heard of Infrastructure as Code and yes these are the various machines which have been virtualized and there is code that we can write that will create that machine repeatedly and with the same success results.  Today I want to talk about Pipeline as code.
## Why Pipeline As Code?
There is always an advantage to anything that you put into source control.  With that you get the history of how those changes came together in the code.  Ever wonder how a bug got fixed, what was changed to make that happen?  Or, even better yet you have been working on something for a while and suddenly you realize that it no longer compiles, builds, or runs and you can't remember what you might have changed to break it.  These are just some of the things that history out of source control can give to you.  Then there is the sharing aspect of source control, when you push your code up to the remote repository your team members can get your latest changes and maybe even put some of their finishing touches on it or maybe they can fix that issue you had.  With pipeline as code and stored in source control it also means that it travels with your source.  Say you are working in a new environment and you want to change the instance of the build machine (which is where the build definition would typically live) but instead you just need to point to you Jenkinfile which contains your pipeline and provided all the dependencies can be resolved you can get this same pipeline working in this new environment.

However, I think the biggest gain that you get from pipeline as code is the fact that I can create a new branch and that means that my pipeline is also part of the new branch.  I could add new aspects to the pipeline that would only make sense in this new pipeline and do not affect other work that might start failing if I messed with the one and only build definition for this project.  Then when I go through the proper pull request and merge my changes with master, the new feature that I wrote and the dependent pipeline changes move together into master.  Basically you could have a situation where new big changes to the project could be worked on and go through the whole normal CI/CD cycle without breaking anything old or new.  With that, lets go back to the history for a minute.  That would mean that if we pulled up a commit from several months back, it would contain the appropriate build pipeline for that version of the source.  I have had many times in the earlier days of my career as a developer struggling with the build on an older version of the code to try and remember what all changed in the build pipeline so that we can build this once again.  Pipeline as code solves all that so what would it look like, lets look at that next.
## Declarative Pipeline
